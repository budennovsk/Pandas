# -*- coding: utf-8 -*-
"""tenserfloy_обучение_модели_3_года.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1et-u2ecegJdGC65v8BNvSDeLIGW5Ezli
"""

import numpy as np

import pandas as pd
import matplotlib.pyplot as plt

# Генерация данных
np.random.seed(0)

days = 1095
sku_count = 10


# Задаем веса для SKU согласно принципу Парето
pareto_weights = (np.arange(sku_count, 0, -1) ** -1.5)
pareto_weights /= pareto_weights.sum()



def calculate_influence(current_sku, other_sku, num_v):
    if num_v == 'min_v':
        return ((current_sku/other_sku) * 0.6)*8.8
    else:
        x = (0.6 * (current_sku - 10 / 100))*8.8
        if x < 0:
            return x*(-1)
        return (0.6 * (current_sku - 10 / 100))*8.8


all_sku = pareto_weights

# Пройдемся по всем SKU и сравним их
def influence():
    influences = [[] for _ in range(len(all_sku))]
    for i, current_sku in enumerate(all_sku):
        for j, other_sku in enumerate(all_sku):
            if current_sku != other_sku:
                if current_sku < other_sku:
                    influence = calculate_influence(current_sku, other_sku, 'min_v')
                    influences[i].append(f"sku_{j+1}_{i+1}: {influence}")
                else:
                    influence = calculate_influence(other_sku, current_sku, 'max_v')
                    influences[i].append(f"sku_{j+1}_{i+1}: {influence}")
    return influences

# Получаем значения влияния в виде вложенного списка с ключами
influences = influence()









def generate_promo_intervals():
    starts = np.sort(np.random.choice(np.arange(1, days - 15), size=15, replace=False))
    return [(start, start + 14) for start in starts]

promo_intervals_per_sku = {sku: generate_promo_intervals() for sku in range(1, sku_count + 1)}
# print(promo_intervals_per_sku)
data = {
    'Day': np.tile(np.arange(1, days + 1), sku_count),
    'SKU': np.repeat(np.arange(1, sku_count + 1), days),
    'Price': np.random.uniform(10, 200, size=days * sku_count),
    'Regular Sales': np.abs(np.random.normal(100, 10, days * sku_count) * np.repeat(pareto_weights, days)),
    'Promo Sales': np.zeros(days * sku_count),
    'Stock': np.random.randint(50, 200, size=days * sku_count)
}

df = pd.DataFrame(data)



new_dicts = []


data = promo_intervals_per_sku

# Создание нового словаря с замененными ключами
new_data = {f"sku_{key}": value for key, value in data.items()}


# Создание списка ключей из исходного словаря
keys = list(data.keys())

# Создание списка словарей без одной строки
#  new_dicts  список интервалов на каждой строке sku*sku
new_dicts = []
d = 0
for i in range(len(keys)):
    d+=1
    new_dict = {f"sku_{key}_{d}": value for key, value in data.items() if key != keys[i]}
    new_dicts.append(new_dict)
# print(new_dicts)









# Недельная сезонность
недельные_коэффициенты = {
    0: 0.9,  # Понедельник
    1: 1.0,  # Вторник
    2: 1.0,  # Среда
    3: 1.1,  # Четверг
    4: 1.3,  # Пятница
    5: 1.5,  # Суббота
    6: 1.4   # Воскресенье
}

# Месячная сезонность
месячные_коэффициенты = {
    1: 1.2, 2: 1.1, 3: 1.0, 4: 0.9, 5: 0.9,
    6: 0.9, 7: 1.0, 8: 1.0, 9: 1.1, 10: 1.1,
    11: 1.2, 12: 1.3, 13: 1.2, 14: 1.1, 15: 1.0, 16: 0.9, 17: 0.9,
    18: 0.9, 19: 1.0, 20: 1.0, 21: 1.1, 22: 1.1,
    23: 1.2, 24: 1.3,
    25: 1.2, 26: 1.1, 27: 1.0, 28: 0.9, 29: 0.9, 30: 0.9,
    31: 1.0, 32: 1.0, 33: 1.1, 34: 1.1, 35: 1.2, 36: 1.3
}

# Праздничная сезонность
праздничные_коэффициенты = {
    1: 1.5,   # Новый год
    45: 1.2,  # День влюбленных
    95: 1.3,  # Пасха
    196: 1.4, # Летние распродажи
    333: 1.7, # Черная пятница
    359: 1.5,  # Рождество
    366: 1.5,   # Новый год
    410: 1.2,  # День влюбленных
    460: 1.3,  # Пасха
    561: 1.4, # Летние распродажи
    698: 1.7, # Черная пятница
    723: 1.5,  # Рождество
    731: 1.5,   # Новый год
    775: 1.2,  # День влюбленных
    825: 1.3,  # Пасха
    926: 1.4, # Летние распродажи
    1063: 1.7, # Черная пятница
    1089: 1.5,  # Рождество
}

def holiday_multiplier(day):
    for holiday, boost in праздничные_коэффициенты.items():
        days_before_holiday = holiday - day
        if 0 <= days_before_holiday <= 6:
            return 1 + (boost - 1) * (1 - days_before_holiday / 7)
    return 1

df['Weekday'] = df['Day'] % 7

df['Seasonality'] = df['Weekday'].map(недельные_коэффициенты)
df['Month'] = ((df['Day'] - 1) // 30) + 1
df['Monthly Seasonality'] = df['Month'].map(месячные_коэффициенты)
df['Holiday Boost'] = df['Day'].apply(holiday_multiplier)
df['Regular Sales'] *= df['Seasonality'] * df['Monthly Seasonality'] * df['Holiday Boost']

for sku, intervals in promo_intervals_per_sku.items():

    for start, end in intervals:


        mask = (df['SKU'] == sku) & (df['Day'] >= start) & (df['Day'] <= end)

        df.loc[mask, 'Price'] *= np.random.uniform(0.7, 0.8)
        promo_increase = np.abs(np.random.normal(200, 15, np.sum(mask)) * pareto_weights[sku-1])
        df.loc[mask, 'Promo Sales'] = promo_increase
        df.loc[mask, 'Regular Sales'] = 0

        other_skus_mask = (df['SKU'] != sku) & (df['Day'] >= start) & (df['Day'] <= end)
        df.loc[other_skus_mask, 'Regular Sales'] *= np.random.uniform(0.7, 0.9)


df['index_promo'] = ''

# Iterate over the 'data' dictionary
for dos in new_dicts:
    for sku, ranges in dos.items():
        for start, end in ranges:
            # Expand the range and check if any value matches the 'DAYS' column
            matching_days = range(start, end + 1)
            df.loc[df['Day'].isin(matching_days), 'index_promo'] = sku

for sublist in influences:

    for item in sublist:
        key, value = item.split(': ')
        df.loc[df['index_promo'] == key, 'res_index_promo'] = float(value)
# замена nan на 1 чтобы умножить столбцы без изменений
df['res_index_promo'].fillna(value=1, inplace=True)
# срез максимальных индексов 286 позиция слишком улетела 4 значение
# df['res_index_promo'] = df['res_index_promo'].apply(lambda x: 1.7 if x > 1.7 else x)
# показ результатов полученных индексов
df['result_1'] = df['Regular Sales'] * df['res_index_promo']
# регулярные индексы с связью sku*sku
df['Regular Sales'] = df['Regular Sales'] * df['res_index_promo']
df['Regular_Sales_Promo_Sales'] = df['Regular Sales'] + df['Promo Sales']
# print(df.loc[230:260])
# index_search = df[df['SKU'] == 10].index[0]
# print(index_search)
# result = (df['SKU'] == 1).all()

# count_zeros_promo = (df['Promo Sales'] == 0).sum()

# print(count_zeros_promo,'count_zeros_promo')  # Вывод количества нулей

# count_zeros_regul = (df['Regular Sales'] == 0).sum()

# print(count_zeros_regul,'count_zeros_Regular Sales')  # Вывод количества нулей
# print(sum([count_zeros_promo,count_zeros_regul]), 'сумма нулей')
# print(df.shape[0], 'total _df')





# Создание модели




for sku in range(1, sku_count + 1):
    plt.figure(figsize=(22, 6))
    subset = df[df['SKU'] == sku]
    plt.plot(subset['Day'], subset['Regular Sales'], label='Regular Sales')
    plt.plot(subset['Day'], subset['Promo Sales'], label='Promo Sales', color='red')
    plt.title(f"Sales for SKU {sku}")
    plt.legend()
    plt.show()

# Суммарные продажи по SKU
total_sales_per_sku = df.groupby('SKU')[['Regular Sales', 'Promo Sales']].sum().sum(axis=1)
plt.figure(figsize=(12, 6))
total_sales_per_sku.plot(kind='bar')
plt.title("Total Sales for Each SKU")
plt.ylabel("Total Sales")
plt.xlabel("SKU")
plt.show()






# Добавим столбец 'Date', чтобы использовать его для группировки по неделям
df['Date'] = pd.to_datetime(df['Day'], origin='2023-01-01', unit='D')

# Группируем по SKU и неделям, затем суммируем продажи
weekly_sales = df.groupby('SKU').apply(lambda group: group.set_index('Date').resample('W').sum())

# Отрисовка графиков недельных продаж для каждого SKU
for sku in range(1, sku_count + 1):
    plt.figure(figsize=(22, 6))

    # Выбор нужного SKU из отсортированных данных
    subset = weekly_sales.loc[sku]

    # Рисуем график недельных продаж
    plt.plot(subset.index, subset['Regular Sales'] + subset['Promo Sales'], label='Total Weekly Sales')
    plt.title(f"Weekly Sales for SKU {sku}")
    plt.ylabel("Sales")
    plt.xlabel("Week")
    plt.legend()
    plt.grid(True)
    plt.show()

import tensorflow as tf
import pandas as pd
import numpy as np
from sklearn.model_selection import train_test_split

# Индексы строк с пропущенными значениями
df.copy()
# Замена значений NaN на 0
df = df.fillna(0)


SEQ_LENGTH = 10

def create_sequences(data, seq_length):
    xs, ys = [], []
    for i in range(len(data) - seq_length):
        x = data[i:(i + seq_length)]
        y = data[i + seq_length, -2]  # -2 так как 'Sales' находится перед 'Stock'
        xs.append(x)
        ys.append(y)
    return np.array(xs), np.array(ys)

sku_data = {}
for sku in range(1, sku_count + 1):
    sku_df = df[df['SKU'] == sku]
    X, y = create_sequences(sku_df[['Price', 'Regular_Sales_Promo_Sales', 'Stock']].values, SEQ_LENGTH)
    sku_data[sku] = (X, y)

"""# Новый раздел

# Новый раздел
"""

from sklearn.model_selection import train_test_split
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import LSTM, Dense
from sklearn.metrics import mean_squared_error




model = Sequential()
model.add(LSTM(64, activation='relu', input_shape=(SEQ_LENGTH, 3), return_sequences=True))
model.add(LSTM(32, activation='relu'))
model.add(Dense(1))
model.compile(optimizer='adam', loss='mse')

for sku, (X, y) in sku_data.items():
    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=0)
    model.fit(X_train, y_train, epochs=5, validation_data=(X_test, y_test))

    predictions = model.predict(X_test)
    # Вычисление ошибки MSE
    mse = mean_squared_error(y_test,predictions)

    print(f"Среднеквадратичная ошибка (MSE) номер {sku}:", mse)
    # Оценка модели на тестовом наборе



def predict_next_n_days(model, initial_data, n_days):
    predicted_data = []
    current_input = initial_data.copy()

    for _ in range(n_days):
        predicted_value = model.predict(np.expand_dims(current_input, axis=0))[0, 0]

        predicted_value = np.maximum(predicted_value, 0)

        new_input = np.roll(current_input, shift=-1, axis=0)
        new_input[-1, 0] = current_input[-1, 0]  # цена
        new_input[-1, 1] = predicted_value       # продажи
        new_input[-1, 2] = current_input[-1, 2]  # остаток

        current_input = new_input
        predicted_data.append(predicted_value)


    return np.array(predicted_data)

predictions = {}
for sku in range(1, sku_count + 1):
    last_data = df[df['SKU'] == sku][['Price', 'Regular_Sales_Promo_Sales', 'Stock']].values[-SEQ_LENGTH:]
    predictions[sku] = predict_next_n_days(model, last_data, 270)


for sku, pred in predictions.items():
    plt.figure(figsize=(22, 6))
    plt.plot(pred, label=f"Predicted Sales for SKU {sku}")
    plt.legend()
    plt.title(f"270 Days Forecast for SKU {sku}")
    plt.show()

